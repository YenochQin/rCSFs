# CSF Descriptor Generator - Python API Guide

## Overview

The CSF (Configuration State Function) Descriptor Generator is a high-performance Rust implementation that converts CSF text data into numerical descriptor arrays for machine learning applications.

## Installation

```bash
# Build and install the Rust extension
cd /Users/yiqin/Documents/ProjectFiles/rCSFs
source .venv/bin/activate
maturin develop --release
```

## Quick Start

```python
from _rcsfs import CSFDescriptorGenerator, py_j_to_double_j

# Step 1: Define your peel subshells (orbital names)
peel_subshells = ['5s', '4d-', '4d', '5p-', '5p', '6s']

# Step 2: Create the generator
generator = CSFDescriptorGenerator(peel_subshells)

# Step 3: Parse CSF data (3 lines per CSF)
line1 = '  5s ( 2)  4d-( 4)  4d ( 6)  5p-( 2)  5p ( 4)  6s ( 2)'
line2 = '                   3/2               2        '
line3 = '                                           4-  '

descriptor = generator.parse_csf(line1, line2, line3)
# Returns: [2.0, 0.0, 0.0, 4.0, 0.0, 0.0, 6.0, 3.0, 3.0, 2.0, 0.0, 0.0, 4.0, 0.0, 8.0, 2.0, 0.0, 8.0]
```

## API Reference

### `py_j_to_double_j(j_str: str) -> int`

Convert a J-value string to its doubled integer representation (2J).

**Parameters:**
- `j_str`: J value as string (e.g., "3/2", "2", "4-")

**Returns:**
- Integer value of 2J

**Examples:**
```python
py_j_to_double_j("3/2")  # → 3
py_j_to_double_j("2")    # → 4
py_j_to_double_j("4-")   # → 8 (parity stripped)
py_j_to_double_j("5/2")  # → 5
```

### `CSFDescriptorGenerator`

#### Constructor

```python
CSFDescriptorGenerator(peel_subshells: list[str])
```

**Parameters:**
- `peel_subshells`: List of orbital names (e.g., ['5s', '4d-', '4d', ...])

#### Methods

##### `parse_csf(line1: str, line2: str, line3: str) -> list[float]`

Parse a single CSF from three separate strings.

**Parameters:**
- `line1`: Subshell configurations and electron counts
- `line2`: Intermediate J coupling values
- `line3`: Final coupling and total J value

**Returns:**
- List of float32 descriptor values

**Descriptor Structure:**
For each orbital, the descriptor contains 3 values:
- `[e_count, middle_J, coupling_J, e_count, middle_J, coupling_J, ...]`

##### `parse_csf_from_list(csf_lines: list[str]) -> list[float]`

Parse a CSF from a list of 3 strings.

**Parameters:**
- `csf_lines`: List of exactly 3 strings

**Returns:**
- List of float32 descriptor values

##### `batch_parse_csfs(csf_list: list[list[str]]) -> list[list[float]]`

Parse multiple CSFs in batch.

**Parameters:**
- `csf_list`: List of CSF data, each being a list of 3 strings

**Returns:**
- List of descriptor arrays

##### `orbital_count() -> int`

Get the number of orbitals.

##### `peel_subshells() -> list[str]`

Get the peel subshells list.

##### `get_config() -> dict`

Get the generator configuration as a dictionary.

## CSF File Format

Each CSF consists of exactly 3 lines:

### Line 1: Subshell Configuration
```
  5s ( 2)  4d-( 4)  4d ( 6)  5p-( 2)  5p ( 4)  6s ( 2)
```
Format: `{orbital} ({count})` repeated for each orbital, 9 characters per block

### Line 2: Intermediate J Coupling
```
                   3/2               2
```
Contains intermediate angular momentum coupling values (9-character blocks)

### Line 3: Final Coupling
```
                                           4-
```
- Characters 1-4: Prefix padding
- Characters 5-End: Coupling values (9-character blocks)
- Last 5 characters: Final J value with parity (e.g., "4-", "3/2")

## Usage Patterns

### Pattern 1: Single CSF Processing

```python
from _rcsfs import CSFDescriptorGenerator

gen = CSFDescriptorGenerator(['5s', '4d-', '4d'])

line1 = '  5s ( 2)  4d-( 4)  4d ( 6)'
line2 = '                   3/2      '
line3 = '                        4-  '

desc = gen.parse_csf(line1, line2, line3)
# desc = [2.0, 0.0, 0.0, 4.0, 0.0, 0.0, 6.0, 3.0, 8.0]
```

### Pattern 2: Batch Processing

```python
csf_batch = [
    ['line1_csf1', 'line2_csf1', 'line3_csf1'],
    ['line1_csf2', 'line2_csf2', 'line3_csf2'],
    # ... more CSFs
]

gen = CSFDescriptorGenerator(['5s', '4d-', '4d'])
descriptors = gen.batch_parse_csfs(csf_batch)
```

### Pattern 3: Processing Parquet Files

```python
import polars as pl
import numpy as np
from _rcsfs import CSFDescriptorGenerator

# Read Parquet file (generated by rCSFs)
df = pl.read_parquet("csfs_data.parquet")

# Get peel subshells from header file
import toml
with open("csfs_data_header.toml") as f:
    header = toml.load(f)
peel_subshells = header["header_info"]["header_lines"][3].split()

# Create generator
gen = CSFDescriptorGenerator(peel_subshells)

# Process with Polars map_elements (vectorized)
def parse_csf(struct_val):
    return gen.parse_csf(struct_val['line1'], struct_val['line2'], struct_val['line3'])

descriptors_df = df.select(
    descriptor = pl.struct(["line1", "line2", "line3"])
        .map_elements(parse_csf, return_dtype=pl.List(pl.Float32))
)

# Convert to numpy for ML
descriptor_matrix = np.array(descriptors_df["descriptor"].to_list(), dtype=np.float32)
print(f"Shape: {descriptor_matrix.shape}")  # (n_csfs, 3 * n_orbitals)
```

### Pattern 4: Integration with GraspKit

```python
from Graspkit.CSFs_processor.CSFs_compress_extract import get_CSFs_peel_subshells
from _rcsfs import CSFDescriptorGenerator
import polars as pl

# Load CSF data from Parquet
df = pl.read_parquet("output.parquet")

# Load header
import toml
with open("csfs_header.toml") as f:
    header = toml.load(f)

# Extract peel subshells (same as Python version)
peel_subshells_line = header["header_info"]["header_lines"][3]
peel_subshells = [s.strip() for s in peel_subshells_line.split() if s.strip()]

# Create generator
gen = CSFDescriptorGenerator(peel_subshells)

# Batch process
def parse_wrapper(struct_val):
    return gen.parse_csf(struct_val['line1'], struct_val['line2'], struct_val['line3'])

descriptors = df.select(
    descriptor = pl.struct(["line1", "line2", "line3"])
        .map_elements(parse_wrapper, return_dtype=pl.List(pl.Float32))
)

# Result is ready for ML training
import numpy as np
X = np.array(descriptors["descriptor"].to_list(), dtype=np.float32)
```

## Descriptor Interpretation

For a CSF with peel_subshells = `['5s', '4d-', '4d']`, the descriptor has 9 values (3 orbitals × 3 values):

| Index | Orbital | Value Type | Description |
|-------|---------|------------|-------------|
| 0 | 5s | e_count | Electron count in 5s orbital |
| 1 | 5s | middle_J | Intermediate J coupling for 5s |
| 2 | 5s | coupling_J | Final J coupling for 5s |
| 3 | 4d- | e_count | Electron count in 4d- orbital |
| 4 | 4d- | middle_J | Intermediate J coupling for 4d- |
| 5 | 4d- | coupling_J | Final J coupling for 4d- |
| 6 | 4d | e_count | Electron count in 4d orbital |
| 7 | 4d | middle_J | Intermediate J coupling for 4d |
| 8 | 4d | coupling_J | Final J coupling for 4d (equals final_J) |

## Performance Notes

- **Single-threaded performance**: ~2-5x faster than Python/NumPy implementation
- **Memory efficient**: Uses f32 (4-byte floats) instead of Python objects
- **Zero-copy**: Returns Python lists that can be converted to NumPy without copying

## Comparison with Python Implementation

| Feature | Python (NumPy) | Rust (rCSFs) |
|---------|----------------|--------------|
| Data type | float64/float32 | float32 |
| Memory | Python objects + numpy array | Contiguous f32 array |
| Speed | Baseline | 2-5x faster |
| Integration | Native | PyO3 bindings |

## Example Output

```python
from _rcsfs import CSFDescriptorGenerator

gen = CSFDescriptorGenerator(['5s', '4d-', '4d'])
desc = gen.parse_csf(
    '  5s ( 2)  4d-( 4)  4d ( 6)',
    '                   3/2      ',
    '                        4-  '
)

print(desc)
# Output: [2.0, 0.0, 0.0, 4.0, 0.0, 0.0, 6.0, 3.0, 8.0]

# Interpretation:
# 5s:  2 electrons, middle_J=0, coupling_J=0
# 4d-: 4 electrons, middle_J=0, coupling_J=0
# 4d:  6 electrons, middle_J=3, coupling_J=8 (final_J=4)
```

## Running the Example Script

```bash
cd /Users/yiqin/Documents/ProjectFiles/rCSFs
source .venv/bin/activate
python examples/descriptor_usage.py
```

This will run through all usage examples with detailed output.
